Aim: Modify the Flask backend (app.py/main.py) to automatically generate a short, descriptive title for new chat conversations using an LLM (via OpenRouter). This title should replace the default "New Conversation" placeholder. The process should be triggered automatically after the first assistant message in a conversation is complete, and it should leverage the existing gevent setup to ensure the API call for summarization doesn't block the server. The frontend will display the new title the next time the conversation list is fetched.

Instructions:

Verify Gevent Monkey-Patching:

Go to the main entry point of your application (likely main.py or the top of app.py).
Confirm that from gevent import monkey and monkey.patch_all() are present and execute before any other imports like Flask, requests, SQLAlchemy, or your application modules (models.py, etc.). This step is essential for requests to perform non-blocking I/O under gevent.
Define the Summarization Function:

Create a new Python function, perhaps named generate_summary, that accepts a conversation_id parameter.
Inside this function, implement the following logic:
Query your database (Message model) to retrieve the content of the first user message and the first assistant message for the given conversation_id. Order by timestamp and limit the query.
Optional but recommended: Query the Conversation model for the given conversation_id. Check if the title field is already set to something other than the default "New Conversation". If it is, you can exit the function early to avoid re-summarizing.
Implement logic to determine the specific OpenRouter model ID to use for summarization (this should be the default free model associated with your Preset 6).
Construct a clear prompt for the LLM. This prompt should instruct the model to create a very short title (e.g., 5 words max) summarizing the topic based on the user and assistant messages you retrieved. Include the message content in the prompt.
Use the standard requests.post method to call the OpenRouter /chat/completions endpoint. Pass the summarization prompt, the chosen model ID, and necessary headers (Authorization token). Set a low max_tokens suitable for a short title.
Process the JSON response from OpenRouter to extract the generated summary text from the choices. Clean up the extracted text (e.g., remove extra quotes or whitespace).
If you didn't query the Conversation object earlier, query it now using the conversation_id.
Update the title attribute of the retrieved Conversation database object with the cleaned summary text.
Commit the changes to the database session (db.session.commit()).
Wrap the logic in a try...except block to catch potential errors during API calls or database operations. Print or log any errors encountered. Remember to potentially call db.session.rollback() in the except block.
Trigger Summarization from the /chat Endpoint:

Navigate to the function handling your /chat POST requests.
Locate the section where the streaming response from the main chat LLM has finished, the complete assistant message content has been assembled, and the corresponding Message object has been saved to the database (likely just before or after the db.session.commit() for the assistant's message). This is also likely near where you yield the final {'type': 'done', ...} SSE event.
After saving the assistant message, add logic to check if this is the first assistant message for this specific conversation_id. You could do this by querying the count of assistant messages for that conversation (Message.query.filter_by(conversation_id=..., role='assistant').count()).
If the count is exactly 1 (meaning the message just saved was the first one), call the generate_summary(conversation_id) function you created in Step 2, passing the current conversation_id.
Ensure this call happens before the /chat function returns or finishes yielding its response stream. Because you're using gevent and have monkey-patched, this call will not block the worker from handling other requests while waiting for the summarization API.
Frontend Interaction (No Change Needed):

Remember that with this backend-only approach (Option A), the frontend JavaScript doesn't need modification to handle the summary update. The updated title will be fetched from the database and displayed in the sidebar the next time the list of conversations is loaded or refreshed (e.g., on page load, or potentially when switching between conversations if your frontend refetches the list then).