

Enhance the chatbot interface by adding action buttons and metadata below user and AI messages, as shown in the attached image. Modify the existing Flask application as follows:

1. Database Modifications (models.py):

Conversation Model:
Add a new column: share_id (String, unique, indexed). This will store a unique, publicly shareable identifier for the conversation.
Message Model:
Add a column: rating (Integer, nullable, default: 0 or null). Used to store user feedback (+1 for upvote, -1 for downvote).
Add columns (for assistant messages): model_id_used (String, nullable), prompt_tokens (Integer, nullable), completion_tokens (Integer, nullable).
Ensure the Message model already has a unique id (primary key) which will be used for targeting ratings.
Update Database: Ensure these schema changes are applied (new columns created).
2. Backend Modifications (app.py):

Share ID Generation:
When a new conversation is created (likely within the /chat endpoint or associated logic):
Generate a cryptographically strong, URL-safe, unique ID (e.g., use uuid.uuid4() then encode it to base62 for a shorter representation, ensuring sufficient uniqueness for trillions of chats).
Save this generated share_id to the new Conversation record in the database.
/chat Endpoint Enhancement:
Token/Model Tracking: Modify the logic that handles the response stream from OpenRouter.
Reliably parse the final data chunk(s) from the SSE stream to extract the usage information (prompt_tokens, completion_tokens) and the exact model ID returned by the API for that specific request.
After the stream completes for an assistant message, update the corresponding Message record in the database with the extracted model_id_used, prompt_tokens, and completion_tokens.
Data for Frontend: Ensure that when conversations are loaded or messages streamed, the necessary data is available to the frontend: message.id, message.rating, conversation.share_id, and for AI messages: message.model_id_used, message.prompt_tokens, message.completion_tokens.
New Endpoint: Rate Message (POST /rate_message/<message_id>):
Create a new route that accepts a message ID (UUID or Int, matching your Message.id type) and a POST request.
The request body should contain the rating (e.g., {'rating': 1} or {'rating': -1}).
Use the temporary session['user_identifier'] to authorize (ensure the user interacting is part of the conversation, although simple validation might suffice for now).
Update the rating column for the specified Message record in the database.
Return a success/error JSON response.
Name Shortening: Ensure the model name shortening utility function is available and used when passing model info to the frontend.
3. Frontend Modifications (static/js/script.js, templates/index.html, static/css/style.css):

Message Rendering (in script.js):
Modify the JavaScript function(s) that render user and assistant message bubbles.
Below each message bubble (User and AI):
Add a div container for action buttons (class="message-actions").
Inside this div, add a "Copy" button (<button class="copy-btn" title="Copy text" data-message-id="{message.id}"><i class="fa-regular fa-copy"></i></button>).
Below AI message bubbles ONLY (inside the message-actions div):
Add a "Share" button (<button class="share-btn" title="Copy share link" data-conversation-share-id="{conversation.share_id}"><i class="fa-solid fa-share-nodes"></i></button>).
Add an "Upvote" button (<button class="upvote-btn" title="Upvote" data-message-id="{message.id}"><i class="fa-regular fa-thumbs-up"></i></button>).
Add a "Downvote" button (<button class="downvote-btn" title="Downvote" data-message-id="{message.id}"><i class="fa-regular fa-thumbs-down"></i></button>).
Visually indicate the current rating (e.g., add an 'active' or 'voted' class to the corresponding up/downvote button if message.rating is +1 or -1).
Below the message-actions div (for AI messages ONLY):
Add a div container for metadata (class="message-metadata").
Inside this div, display the information (if available): Model: {shortened_model_name} Â· Tokens: {prompt_tokens} prompt + {completion_tokens} completion. Use the shortened name. Handle cases where token/model data might be null gracefully (e.g., don't display that part).
Dynamic Metadata Update: For newly streamed AI messages, the metadata (model, tokens) might only be available after the stream finishes. Update the rendering logic: Append the text content as it streams, and once the stream is complete and the backend provides the metadata (e.g., via a final SSE event or a separate mechanism), dynamically add or update the .message-metadata div for that specific message bubble.
Event Listeners (script.js):
Copy Button (.copy-btn):
Add a delegated event listener for clicks.
Find the associated message text content.
Use navigator.clipboard.writeText() to copy the text.
Provide brief visual feedback (e.g., change icon, show tooltip "Copied!"). Handle potential errors (e.g., clipboard API not available).
Share Button (.share-btn):
Add a delegated event listener for clicks.
Get share_id from data-conversation-share-id.
Construct the full shareable URL (window.location.origin + '/share/' + share_id).
Use navigator.clipboard.writeText() to copy the URL.
Provide visual feedback (e.g., "Link Copied!").
Upvote/Downvote Buttons (.upvote-btn, .downvote-btn):
Add delegated event listeners for clicks.
Get message_id from data-message-id.
Determine rating value (+1 or -1).
Send a POST request to /rate_message/{message_id} with the rating.
On success:
Update the button's visual state (e.g., add 'voted' class to clicked button, remove from sibling).
Optionally disable both buttons after voting, or implement logic to allow changing/removing votes by sending a new rating (or 0) to the backend. Start with just setting the vote.
Handle potential errors from the backend request.
Styling (style.css):
Style the .message-actions container (e.g., display: flex, spacing).
Style the action buttons (padding, border, background, icon size, cursor). Add hover effects.
Style the .message-metadata container (font size, color, margins).
Add CSS rules for visual feedback (e.g., .copy-btn.copied, .share-btn.copied, .upvote-btn.voted, .downvote-btn.voted).
4. Safety and Precision:

Ensure the share_id generation is robustly unique (Base62 encoded UUID recommended).
Implement careful parsing of the OpenRouter SSE stream to capture usage data reliably.
Handle database operations safely (use transactions if necessary, handle potential errors).
Protect the /rate_message endpoint using the session identifier.
Implement frontend error handling for clipboard actions and API calls.
Ensure dynamic addition/update of metadata for streamed responses works correctly without layout shifts if possible.
Update the relevant files (models.py, app.py, static/js/script.js, static/css/style.css, templates/index.html if static elements are added) to implement these features thoroughly.

